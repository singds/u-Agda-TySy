\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{minted} % for code fragments
\usepackage{fontspec}
\usepackage{mathpartir} % for typing rules and derivation trees
\usepackage[
    backend=biber,
    style=alphabetic,
    sorting=ynt
]{biblatex}


\setminted[agda]{encoding=utf8, linenos}
\setmonofont[Scale=0.84]{DejaVu Sans Mono}
\addbibresource{bibliography.bib}

\title{$\mu$ Agda TySy}
\author{Giacomo Dal Sasso}
\date{June 2022}

\begin{document}

\maketitle


\section{Preface}

I decided to develop this project while I was following courses of Type Theory and Advanced topics in programming languages in Univerity of Padova.
In the former course I was studying how to develop formal proof using Martin-Löf's type theory while in the latter we were formalizing a functional language and its type system.
So I thought it was a great idea seeing how the same language and proofs about its type system can be developed in Agda.


\subsubsection*{Agda stdlib}
The Agda core, as a functional programming language, provides very little to programmers.
In the Agda core there is no implementation for arrays or lists, neither there is the definition for common types such as booleans or natural numbers.
Despite of that, list, boolean, integer and other useful types, as functions operating on those types, can be defined by the programmer itself using core features of the language.
Actually a bunch of types and useful functions are already defined in the Agda standard library that builds on top of Agda core.
Since Agda is a proof assistant as well, the standard library contains also proofs.
As an example, the standard library may contain: the definition of the type of natual numbers N, the definition of the binary operator +, and a proof of the commutative property for addition (a + b = b + a).

As in any other programming language, to be sufficiently productive one should learn how to leverage the standard library.
Note how learning to use the stdlib means also to learn proofs that are already there and to train yourself on developing new proofs you need in terms of facts already proved.
Since I was new to Agda when developing this project and I wanted to deal with all small details, I decided not to use the library.
So the project is self contained; all was developed from scratch on top of the Agda core.\\

This project was for me a perfect way to improve in a single shot Agda, Martin-Löf's type theory and type systems formalization understanding and knowledge.
Developing the project I had both to simply formalize in Agda blackboard-proofs already done during courses and to develop new, lets say original, proofs.
I think this project may be a fair challenge for any student interested on those topics.


\section{Introduction}

The purpose of this project is to formalize in Agda a basic functional language with its type system and to prove the well known safety theorem.


\subsubsection*{Agda}
Agda is a functional programming language based on Martin-Löf's Type Theory.
The main feature of the language is dependent types.
Dependent type are types that can depend (that are parameterized) on values of other types.

In common mainstream programming languages such as Java we have Generics: types that depends on other types.
As an example, in Java we can define the type List<T> that is a generic type that can be instantiated providing some other type, such as Integer or String, as parameter T.
List<Integer> represents the type of lists containing integers as elements.
Parameters you pass in the instantiation of generic types are always other types, they can't be values.
In List<T>, T must be a type and can't be a value.

In Agda we can define the type List : (T : Set) → (n : Nat) → Set of lists of length n containing elements of type T.
The type List Nat 4 would be the type of lists with length 4 containing natural numbers.
This type can't be represented in Java; the second parameter of the list type is a value of type Nat, not a type.

Dependent types can be used to define propositions by means of Curry–Howard correspondence, such that proofs can be developed within the language.
In the same language we can develop useful code, such as algorithms, but also prove properties of code.
We could develop a sorting algorithm and also prove its correctness, all inside Agda.

All functions that can be defined in Agda are total and computable, that is, evaluates to a final value in a finite number of steps.


\subsubsection*{Project structure}

The project codebase is divided in multiple files.
The root directory contains a README.md that provides an overview of files content.
If you are in hurry and you want just to have a glance of the project, you can start from type-system.agda.


\section{Formalization}

\subsubsection*{Terms}

\begin{minted}{agda}
data Term : Set where
  true          :                              Term
  false         :                              Term
  num           : (n : ℕ)                    → Term
  if_then_else_ : Term → Term → Term         → Term
  _+ₙ_          : Term → Term                → Term
  var           : (x : ℕ)                    → Term
  _app_         : (e1 : Term) → (e2 : Term)  → Term
  fun           : (t : Type) → (e1 : Term)   → Term
\end{minted}

One of the first thing we have to define are the terms of the language.
Term is a type (non-dependent) with one constructor for each kind of expression admitted by the language.
The formalized language is a basic functional language with booleans, natural numbers and the if-then-else construct.
The same language is treated in \cite{crafa}[Ch.\ 4] and a similar one can be found in \cite[Ch.\ 9]{pierce}.

The Term type has \texttt{eight} constructors.
Each constructor encodes a different way to produce a value of type \texttt{Term}.
\texttt{true} is a constructor with no parameters that is on its own a value of type \texttt{Term}.
\texttt{\_app\_} is another constructor that given two values of type Term as inputs, produces a new value of type \texttt{Term}.
\texttt{\_app\_} behaves like a function in curried form.
The prepended and postponed \texttt{\_} makes the \texttt{\_app\_} constructor usable as in infix binary operator, such that the application of the term \texttt{m1} to the term \texttt{m2} can be written as \texttt{m1 app m2} instead of \texttt{\_app\_ m1 m2}.

Here are some examples of valid terms.
Observe how \texttt{tm4} is a valid term although not well typed.

\begin{minted}{agda}
tm1 = true
tm2 = if true then (num 1) else (num 0)
tm3 = (num 1) +ₙ (num 2)
tm4 = true app false
tm5 = fun Bool (var 0)
\end{minted}

This way of representing terms should be mostly familiar to the reader.
The major difference between the common way of representing terms and this way resides in the representation of variables and lambda abstractions.
Variables are encoded as natural numbers (not labels) and functions don't carry along a parameter name.
Inside a function term is only stored the type \texttt{t} of its parameter and the the body \texttt{e1} of the function.
This way of representing terms was devised by Nicolaas de Brujin \cite[Ch.\ 6]{pierce}.
Terms in this form are called nameless terms or de Brujin terms.

A variable in a nameless term is an index that points to a precise enclosing lambda abstraction.
The variable with number k stands for the "the variable bound by the k'th enclosing $\lambda$" \cite[Ch.\ 6 p.\ 76]{pierce}.
% For example, the variable \texttt{(var 0)} in \texttt{fun Nat (fun Bool (var 0))} references the boolean parameter introduces by the innermost abstraction while \texttt{(var 1)} in \texttt{fun Nat (fun Bool (var 1))} references the integer parameter introduced by the outermost lambda.
For example, the term \texttt{fun Nat (fun Bool (var 0))} has type \texttt{Nat→Bool→Bool} since \texttt{(var 0)} references the boolean parameter introduces by the innermost abstraction.
\texttt{fun Nat (fun Bool (var 1))} has type \texttt{Nat→Bool→Nat} instead, because \texttt{(var 1)} references the integer parameter introduced by the outermost lambda.

Here is a table showing some examples of named terms and corresponding nameless terms of our language.
For even more examples I suggest watching exercise $6.1.1$ \cite[p.\ 76]{pierce} whose solution can be found at \cite[p.\ 503]{pierce}.

\begin{center}
\begin{tabular}{ |c|c| } 
 \hline
 & named term \\
 \hline
 \texttt{tm6} & \texttt{$\lambda$x:Bool.x} \\
 \texttt{tm7} & \texttt{$\lambda$x:Bool $\lambda$y:Nat. if x then y else 0} \\
 \texttt{tm8} & \texttt{(($\lambda$x:Nat.x) 1) +ₙ (($\lambda$y:Nat.y) 2)} \\
 \hline
 \hline
 
 & nameless term \\
 \hline
 \texttt{tm6} & \texttt{fun Bool (var 0)} \\
 \texttt{tm7} & \texttt{fun Bool (fun Nat (if var 1 then var 0 else num 0))} \\
 \texttt{tm8} & \texttt{((fun Nat var 0) num 1) +ₙ ((fun Nat var 0) num 2)} \\
 
 \hline
\end{tabular}
\end{center}

The most interesting property of de Brujin terms is that the representation of a term is unique.
$\lambda x.x$ and $\lambda y.y$ are two equivalent ways of representing the identity function as a named term, while $\lambda.0$ is the only way of representing the same function as a nameless term.
In our language the identity function for boolean values is \texttt{tm5}.


\subsection*{Environment}

\begin{minted}{agda}
Env = List {Type}
\end{minted}

An environment for nameless terms is just a list of types.
The environment doesn't contain bindings between variable names and types, but only types.
The order in which types appear in the environment is important.
Note that this is not true for standard environments: the term $x \; y$ is well typed both in the environment $\Gamma_1 = x:\text{Nat} \to \text{Nat}, y:\text{Nat}$ and in $\Gamma_2 = y:\text{Nat}, x:\text{Nat} \to \text{Nat}$. 

Here are some examples of valid environments.
The element of the list with index 0 is the leftmost.

\begin{minted}{agda}
env1 = Bool ∷ []
env2 = Nat ∷ Tarrow Nat Bool ∷ []
env3 = Bool ∷ Nat ∷ Tarrow (Tarrow Nat Nat) Bool ∷ []
\end{minted}

As we will see later, the term \texttt{var 0} will be of type \texttt{Bool} in \texttt{env1} while it will be of type \texttt{Nat} in \texttt{env2}.
This because the type assigned to variable 0 is the type with index 0 of the environment.

Observe how every list of types is well formed context; there is no need to ask for variable names in the context to be distinct, because there are actually no variables names.


\subsection*{Free variables}

With this new way of representing terms comes a new definition for free variables.
Commonly, the set of free variables of a term is defined as the set of labels for which does not exists an enclosing abstraction that introduce that label.
A variable is free when there is no abstraction that binds it.
So the set of free variables of a term represents the smallest set of labels for which a binding must be present in the environment for there to be a possibility that the term is well typed in that environment.
$\lambda x. x + y$ may be well typed only in an environment that contains a binding at least for the label $y$.

With this notion in mind we can come up with a definition of free variables for de Brujin terms.
The list of free variables of a term is the list of indices that must be available in an environment to type that term.

In the term \texttt{var 0}, 0 is a free variable because there is no lambda abstraction to which the variable points.
An environment with length at least 1 is needed to type this term.
In the term \texttt{fun Bool (var 1)} the free variable is 0 (not 1).
To type this term we need an environment that specify a type at least for index 0.
A term with free variables [3, 5, 1] can only be typed in an environment with length at least 6.

Here are some examples of terms with corresponding free variables.

\begin{minted}{text}
fv(var 1)             = [1]
fv(fun Bool (var 0))  = []
fv(fun Nat (var 1))   = [0]
fv(fun Bool (var 2))  = [1]
fv(fun Nat fun Bool
     (if (var 0) then (var 1) else (var 2) +ₙ (var 3))) = [0,1]
\end{minted}


\subsection*{Typing rules}

\begin{minted}{agda}
data HasType : Env → Term → Type → Set where

-- ... some cut content here

  t-nat   : {Γ : Env} {n : ℕ}
            → HasType Γ (num n) Nat

  t-var   : {Γ : Env} {x : ℕ} {t : Type}
            → (p : (getIdx Γ x) ≡ some t)
            → HasType Γ (var x) t
            
  t-fun   : {Γ : Env} {t1 t2 : Type} {m : Term}
            → (p : HasType (t1 ∷  Γ) m t2)
            → HasType Γ (fun t1 m) (Tarrow t1 t2)
\end{minted}

To encode typing rules we define the dependent type \texttt{HasType}.
\texttt{HasType} depends on a value of type \texttt{Env}, on a term and on a type of our language.
The type \texttt{HasType $\Gamma$ M T} corresponds to the following proposition:

\vspace{1em}
\textit{In environment $\Gamma$, the term $M$ has type $T$.}
\vspace{1em}

\texttt{HasType} can be seen as a function that accepts three arguments and produces a value of type \texttt{Set}, that is a type.
\texttt{Set} is the type of small types.
An elements of type \texttt{HasType $\Gamma$ M T} corresponds to a witness that the term \texttt{M} has type \texttt{T} in the environment \texttt{$\Gamma$}.
Therefore producing an element of type \texttt{HasType $\Gamma$ M T} corresponds to proving the associated proposition.

Each constructor of \texttt{HasType} encodes one typing rule.
A complete set of typing rules is in \cite[p.\ 15]{crafa}.

The constructors \texttt{t-nat}, \texttt{t-var} and \texttt{t-fun} encode respectively \texttt{T-NAT}, \texttt{T-VAR} and \texttt{T-FUN} rules.

\begin{mathpar}

\inferrule[(T-NAT)]
{ }
{\Gamma \vdash n : \text{Nat}}

\and

\inferrule[(T-VAR)]
{ }
{\Gamma \vdash n : \text{Nat}}
\; x:T \in \Gamma

\and

\inferrule[(T-FUN)]
{\Gamma,x:T_1 \vdash M : T_2}
{\Gamma \vdash \lambda x:T_1. M : T_1 \to T_2}

\end{mathpar}




\newpage
\nocite{*}
\printbibliography

\end{document}
