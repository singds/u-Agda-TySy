\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{minted}
\usepackage{fontspec}
\usepackage[
    backend=biber,
    style=alphabetic,
    sorting=ynt
]{biblatex}


\setminted[agda]{encoding=utf8, linenos, fontsize=\small}
\setmonofont{DejaVu Sans Mono}
\addbibresource{bibliography.bib}

\title{$\mu$ Agda TySy}
\author{Giacomo Dal Sasso}
\date{June 2022}

\begin{document}

\maketitle


\section{Preface}

I decided to develop this project while I was following courses of Type Theory and Advanced topics in programming languages in Univerity of Padova.
In the former course I was studying how to develop formal proof using Martin-Löf's type theory while in the latter we were formalizing a functional language and its type system.
So I thought it was a great idea seeing how the same language and proofs about its type system can be developed in Agda.


\subsubsection*{Agda stdlib}
The Agda core, as a functional programming language, provides very little to programmers.
In the Agda core there is no implementation for arrays or lists, neither there is the definition for common types such as booleans or natural numbers.
Despite of that, list, boolean, integer and other useful types, as functions operating on those types, can be defined by the programmer itself using core features of the language.
Actually a bunch of types and useful functions are already defined in the Agda standard library that builds on top of Agda core.
Since Agda is a proof assistant as well, the standard library contains also proofs.
As an example, the standard library may contain: the definition of the type of natual numbers N, the definition of the binary operator +, and a proof of the commutative property for addition (a + b = b + a).

As in any other programming language, to be sufficiently productive one should learn how to leverage the standard library.
Note how learning to use the stdlib means also to learn proofs that are already there and to train yourself on developing new proofs you need in terms of facts already proved.
Since I was new to Agda when developing this project and I wanted to deal with all small details, I decided not to use the library.
So the project is self contained; all was developed from scratch on top of the Agda core.\\

This project was for me a perfect way to improve in a single shot Agda, Martin-Löf's type theory and type systems formalization understanding and knowledge.
Developing the project I had both to simply formalize in Agda blackboard-proofs already done during courses and to develop new, lets say original, proofs.
I think this project may be a fair challenge for any student interested on those topics.


\section{Introduction}

The purpose of this project is to formalize in Agda a basic functional language with its type system and to prove the well known safety theorem.


\subsubsection*{Agda}
Agda is a functional programming language based on Martin-Löf's Type Theory.
The main feature of the language is dependent types.
Dependent type are types that can depend (that are parameterized) on values of other types.

In common mainstream programming languages such as Java we have Generics: types that depends on other types.
As an example, in Java we can define the type List<T> that is a generic type that can be instantiated providing some other type, such as Integer or String, as parameter T.
List<Integer> represents the type of lists containing integers as elements.
Parameters you pass in the instantiation of generic types are always other types, they can't be values.
In List<T>, T must be a type and can't be a value.

In Agda we can define the type List : (T : Set) → (n : Nat) → Set of lists of length n containing elements of type T.
The type List Nat 4 would be the type of lists with length 4 containing natural numbers.
This type can't be represented in Java; the second parameter of the list type is a value of type Nat, not a type.

Dependent types can be used to define propositions by means of Curry–Howard correspondence, such that proofs can be developed within the language.
In the same language we can develop useful code, such as algorithms, but also prove properties of code.
We could develop a sorting algorithm and also prove its correctness, all inside Agda.

All functions that can be defined in Agda are total and computable, that is, evaluates to a final value in a finite number of steps.


\subsubsection*{Project structure}

The project codebase is divided in multiple files.
The root directory contains a README.md that provides an overview of files content.
If you are in hurry and you want just to have a glance of the project, you can start from type-system.agda.


\section{Formalization}

\subsubsection*{Terms}

One of the first thing we have to define are the terms of the language.
Term is a type (non-dependent) with one constructor for each kind of expression admitted by the language.
The formalized language is a basic functional language with booleans, natural numbers and an if-then-else construct.
A similar language can be found in \cite[Ch.\ 9]{pierce}


\begin{minted}{agda}
data Term : Set where
  true          :                              Term
  false         :                              Term
  num           : (n : ℕ)                    → Term
  if_then_else_ : Term → Term → Term         → Term
  _+ₙ_          : Term → Term                → Term
  var           : (x : ℕ)                    → Term
  _app_         : (e1 : Term) → (e2 : Term)  → Term
  fun           : (t : Type) → (e1 : Term)   → Term
\end{minted}

Note that both natural numbers and variables are represented by natural numbers.
There needs to be a way to distinguish between actual natural numbers and variables.

\begin{align*}
Terms \; M & ::= \text{var} \; x       & x \in \mathbb{N} \\
& | \quad \text{num} \; n              & n \in \mathbb{N} \\
& | \quad true \; | \; false \\
& | \quad M_1 + M_2 \\
& | \quad \text{if} \; M_1 \; \text{then} \; M_2 \; \text{else} \; M_3 \\
& | \quad \lambda . \; M_1 \\
& | \quad M_1 M_2
\end{align*}

\newpage
\nocite{*}
\printbibliography

\end{document}
